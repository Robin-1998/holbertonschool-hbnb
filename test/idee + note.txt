PYTHONPATH=$(pwd)/part2 python3 -m test_part2.test_place


"""
def validate_password(self, password):
Valide la complexité du mot de passe, et retourne un hash sécurisé.

if len(password) < 12:
        raise ValueError(
            "Le mot de passe doit contenir au moins 12 caractères")
    if not re.search(r"[A-Z]", password):
        raise ValueError("Le mot de passe doit contenir une majuscule")
    if not re.search(r"[a-z]", password):
        raise ValueError("Le mot de passe doit contenir une minuscule")
    if not re.search(r"[\d]", password):
        raise ValueError("Le mot de passe doit contenir un chiffre")
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        raise ValueError(
            "Le mot de passe doit contenir un caractère spécial")
    return generate_password_hash(password, method="pbkdf2:sha256",
                                  salt_length=16)
def check_password(self, password):

Vérifie si raw_password(mot de passe clair) correspond
au mot de passe haché stocké.

    return check_password_hash(self.__password_hashé, password)
"""



idée Package - Class

- Partie utilisateur
	- envoyer SMS
	- ajout d'une photo à l'utilisateur
	- confirmation email (pour activation?)

Note diagram package : 
L’API principale reçoit toutes les requêtes externes (Utilisateurs ou clients).
Elle applique d’abord les fonctionnalités transversales (authentification, logging, limitation de requêtes, etc.).
Ensuite, elle dirige chaque requête vers la sous-API spécialisée qui gère le domaine concerné.

Les sous-API sont des modules spécialisés,
  chacun dédié à un domaine précis
Elles reçoivent les requêtes de l’API principale,
  gèrent les opérations spécifiques à leur domaine,
  puis transmettent les demandes à la logique métier via la façade.
Cette organisation modulaire simplifie le code, facilite la maintenance,
  et permet d’appliquer des règles propres à chaque domaine
  tout en évitant que l’API principale devienne trop complexe.

La façade oriente les appels vers la bonne logique métier,
  simplifiant les interactions.
Elle organise et facilite le travail avec les données.
Elle fait le lien entre la présentation et les données.

Ces "modèles" représentent les objets importants :
Utilisateur, Lieu, Avis, Équipement.
Ils contiennent les règles du métier par exemple :
→ Le prix total dépend du nombre de nuits.
→ Un utilisateur ne peut pas réserver un lieu dans le passé.
→ Un avis ne peut être posté que si une réservation existe.

Un Repository (dépôt) est une interface entre la logique métier
  et la base de données.
Il permet à la couche métier de "parler" à la base de données
  sans s’occuper des détails techniques.
Il centralise l’accès aux données
(lecture, écriture, mise à jour, suppression).
Il cache les détails techniques
(comme les requêtes SQL ou les appels ORM).
Il sépare les responsabilités :
→ La logique métier se concentre sur le métier,
→ Le repository se concentre sur la persistance des données.

Une base de données contient des tables
qui ressemblent à des tableaux Excel.
Chaque table est composée de colonnes
(attributs) et de lignes (enregistrements).
Chaque ligne possède une clé primaire
qui l'identifie de manière univoque cet enregistrement.
Pour interagir avec la base de données,
on utilise des requêtes SQL (bas lvl).
Pour faciliter le travail, les développeurs
utilisent souvent un ORM (Object-Relational Mapping),
qui traduit les opérations en SQL en manipulations
d’objets dans le langage de programmation (haut lvl).
